// web server provides
package main

import (
    "log"
    "strconv"
    "net/http"
    "os"
    "os/exec"
    "sync"
    "path"
    "regexp"
    "flag"
    "encoding/json"
    "html/template"
    "github.com/jnb666/gogp/stats"
)

var (
    Debug bool
    WebBrowser = []string{
        "/etc/alternatives/gnome-www-browser",
        "/etc/alternatives/x-www-browser",
        "google-chrome",
        "firefox",
    }
    dataPath = regexp.MustCompile("/([a-zA-Z]+)+/([0-9]+)$")
)

// history stats generated by model
type Data struct {
    sync.Mutex
    Stats   stats.StatsHistory
    MaxGens int
    Done    bool
}

// plot data which is sent as JSON
type plotData struct {
    Done    bool
    MaxGens int
    Stats   [][]string
    Plots   []stats.Plot
}

// template struct replacements
type pageData struct {
    Headers []*header
}

type header struct {
    Text    string
    Last    bool
}

// serve a static file from under webRoot directory, parses HTML templates passing pageData struct
func FileHandler(webRoot string) func(http.ResponseWriter, *http.Request) {
    return func (w http.ResponseWriter, r *http.Request) {
        if Debug { log.Println("fileHandler:", r.URL.Path) }
        fileName := webRoot + r.URL.Path
        if r.URL.Path == "/" {
            fileName += "index.html"
        }
        if path.Ext(fileName) == ".html" {
            t, err := template.ParseFiles(fileName)
            if err != nil {
                http.Error(w, err.Error(), http.StatusInternalServerError)
                return
            }
            cols := stats.LogHeaders()
            headers := make([]*header, len(cols))
            for i, col := range cols {
                headers[i] = &header{ col, i==len(cols)-1 }
            }
            t.Execute(w, &pageData{headers})
        } else {
            http.ServeFile(w, r, fileName)
        }
    }
}

// serve stats data from history struct
// URL is of form /data/<field>/<from gen>
func DataHandler(history *Data) func(http.ResponseWriter, *http.Request) {
    return func (w http.ResponseWriter, r *http.Request) {
        if Debug { log.Println("dataHandler:", r.URL.Path) }
        fields := dataPath.FindStringSubmatch(r.URL.Path)
        if fields == nil {
            http.NotFound(w, r)
            return
        }
        history.Lock()
        defer history.Unlock()
        data := plotData{ Done: history.Done, MaxGens: history.MaxGens }
        // get stats
        from, err := strconv.Atoi(fields[2])
        if err != nil {
            http.Error(w, err.Error(), http.StatusInternalServerError)
            return
        }
        data.Stats = [][]string{}
        for _, s := range history.Stats[from:] {
            data.Stats = append(data.Stats, s.LogValues())
        }
        // get plots
        data.Plots, err = history.Stats.Get(fields[1])
        if err != nil {
            http.Error(w, err.Error(), http.StatusInternalServerError)
            return
        }
        // convert to JSON and serve content
        jsonData, err := json.Marshal(data)
        if err != nil {
            http.Error(w, err.Error(), http.StatusInternalServerError)
            return
        }
        w.Header().Set("Content-Type", "application/json")
        w.Header().Set("Content-Length", strconv.Itoa(len(jsonData)))
        w.Write(jsonData)
    }
}

// point a web browser to url - assumes Linux
func startBrowser(url string) {
    for _, name := range WebBrowser {
        cmd := exec.Command(name, url)
        if err := cmd.Start(); err == nil { 
            log.Println("started browser", name, url)    
            return
        }
    }
    log.Println("no browser found - go to", url, "to view the data")
}

// main server loop
func main() {
    // get args
    var portNumber int
    var webRoot string
    cdir, _ := os.Getwd()
    flag.StringVar(&webRoot, "root", cdir+"/docs", "root directory for web docs")
    flag.IntVar(&portNumber, "port", 8080, "port number for web server")
    flag.BoolVar(&Debug, "debug", false, "log debug info")
    flag.Parse()
    // initialise
    problem, historyData := createModel()
    http.HandleFunc("/data/", DataHandler(historyData))
    http.HandleFunc("/", FileHandler(webRoot))
    // run
    go runModel(problem, historyData)
    port := ":" + strconv.Itoa(portNumber)
    startBrowser("http://localhost" + port)
    http.ListenAndServe(port, nil)
}


