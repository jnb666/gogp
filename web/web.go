// web server provides
package main

import (
    "log"
    "strconv"
    "net/http"
    "os"
    "os/exec"
    "sync"
    "path"
    "regexp"
    "flag"
    "net"
    "encoding/gob"
    "encoding/json"
    "html/template"
    "github.com/jnb666/gogp/stats"
)

var (
    TCPPort = ":5555"
    Debug bool
    WebBrowser = []string{
        "/etc/alternatives/gnome-www-browser",
        "/etc/alternatives/x-www-browser",
        "google-chrome",
        "firefox",
    }
    dataPath = regexp.MustCompile("/([a-zA-Z]+)+/([0-9]+)$")
)

// history stats generated by model
type Data struct {
    sync.Mutex
    Stats  stats.StatsHistory
    MaxGen int
}

// plot data which is sent as JSON
type plotData struct {
    Done   bool
    MaxGen int
    Stats  [][]string
    Plots  []stats.Plot
}

// template struct replacements
type pageData struct {
    Headers []header
}

type header struct {
    Text    string
    Last    bool
}

// serve a static file from under webRoot directory, 
// parses HTML templates passing pageData struct
func FileHandler(webRoot string) func(http.ResponseWriter, *http.Request) {
    return func (w http.ResponseWriter, r *http.Request) {
        if Debug { log.Println("fileHandler:", r.URL.Path) }
        fileName := webRoot + r.URL.Path
        if r.URL.Path == "/" {
            fileName += "index.html"
        }
        if path.Ext(fileName) == ".html" {
            t, err := template.ParseFiles(fileName)
            if err != nil {
                http.Error(w, err.Error(), http.StatusInternalServerError)
                return
            }
            cols := stats.LogHeaders()
            headers := make([]header, len(cols))
            for i, col := range cols {
                headers[i] = header{ col, i==len(cols)-1 }
            }
            t.Execute(w, &pageData{headers})
        } else {
            http.ServeFile(w, r, fileName)
        }
    }
}

// serve stats data from history struct
// URL is of form /data/<field>/<from gen>
func DataHandler(history *Data) func(http.ResponseWriter, *http.Request) {
    return func (w http.ResponseWriter, r *http.Request) {
        if Debug { log.Println("dataHandler:", r.URL.Path) }
        fields := dataPath.FindStringSubmatch(r.URL.Path)
        if fields == nil {
            http.NotFound(w, r)
            return
        }
        history.Lock()
        defer history.Unlock()
        data := plotData{ MaxGen: history.MaxGen }
        // get stats
        from, err := strconv.Atoi(fields[2])
        if err != nil {
            http.Error(w, err.Error(), http.StatusInternalServerError)
            return
        }
        data.Stats = [][]string{}
        for _, s := range history.Stats[from:] {
            data.Stats = append(data.Stats, s.LogValues())
            data.Done = s.Done
        }
        // get plots
        data.Plots, err = history.Stats.Get(fields[1])
        if err != nil {
            http.Error(w, err.Error(), http.StatusInternalServerError)
            return
        }
        // convert to JSON and serve content
        jsonData, err := json.Marshal(data)
        if err != nil {
            http.Error(w, err.Error(), http.StatusInternalServerError)
            return
        }
        w.Header().Set("Content-Type", "application/json")
        w.Header().Set("Content-Length", strconv.Itoa(len(jsonData)))
        w.Write(jsonData)
    }
}

// point a web browser to url - assumes Linux
func startBrowser(url string) {
    for _, name := range WebBrowser {
        cmd := exec.Command(name, url)
        if err := cmd.Start(); err == nil { 
            log.Println("started browser", name, url)    
            return
        }
    }
    log.Println("no browser found - go to", url, "to view the data")
}

// read stats from channel and update history
func updateData(history *Data, ln net.Listener) {
    if Debug { log.Println("listening on port", TCPPort) }
    for {
        conn, err := ln.Accept()
        if err != nil {
            log.Fatal("error in Accept on", TCPPort, err)
        }
        if Debug { log.Println("accepted connection") }
        dec := gob.NewDecoder(conn)
        history.Reset()
        for {
            s := &stats.Stats{}
            if err = dec.Decode(s); err != nil {
                log.Fatal("error in gob Decode", err)
            }
            if Debug { log.Println(s) }
            history.Append(s)
            if s.Done { break }
        }
        if Debug { log.Println("end of run") }
    }
}

// data methods
func NewData(maxGen int) *Data {
    return &Data{ Stats: stats.StatsHistory{}, MaxGen: maxGen }
}

func (d *Data) Reset() {
    d.Lock()
    d.Stats = stats.StatsHistory{}
    d.Unlock()
}

func (d *Data) Append(s *stats.Stats) {
    d.Lock()
    d.Stats = append(d.Stats, s)
    d.Unlock()
}

// main server loop
func main() {
    // get args
    var browser bool
    var webPort int
    var webRoot string
    cdir, _ := os.Getwd()
    flag.StringVar(&webRoot, "root", cdir+"/docs", "root directory for web docs")
    flag.IntVar(&webPort, "port", 8080, "port number for web server")
    flag.BoolVar(&Debug, "debug", false, "log debug info")
    flag.BoolVar(&browser, "browser", false, "start web browser")
    flag.Parse()
    // initialise 
    data := NewData(20)                             // TODO get MaxGen dynamically
    http.HandleFunc("/data/", DataHandler(data))
    http.HandleFunc("/", FileHandler(webRoot))
    ln, err := net.Listen("tcp", TCPPort)
    if err != nil {
        log.Fatal("error in Listen on", TCPPort, err)
    }
    // run
    go updateData(data, ln)
    port := ":" + strconv.Itoa(webPort)
    if browser {
        startBrowser("http://localhost" + port)
    }
    if err = http.ListenAndServe(port, nil); err != nil {
        log.Fatal("ListenAndServe: ", err)
    }
}




