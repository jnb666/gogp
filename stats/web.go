package stats

import (
    "fmt"
    "log"
    "sync"
    "strconv"
    "os/exec"
    "net/http"
    "encoding/json"
    "github.com/jnb666/gogp/gp"
)

// WebBrowser has paths to possible location of browser on this system
var WebBrowser = []string{
    "/etc/alternatives/gnome-www-browser",
    "/etc/alternatives/x-www-browser",
    "google-chrome",
    "firefox",
}

type plotFunc func(gp.Population) Plot

type stepMsg struct{
    Gen int
    Done bool
}

type empty struct{}

// Logger struct holds stats generated by model for each generation.
// It may be read and written by multiple threads so access is synced using a mutex.
// It implements the gp.Logger interface.
// If OnStep is non nil then it is called with best individual at each generation.
// If OnDone is non nil then it is called with best individual at end of run.
type Logger struct {
    sync.Mutex
    MaxGen          int
    TargetFitness   float64
    PrintStats      bool
    PrintBest       bool
    OnStep          func(best *gp.Individual)
    OnDone          func(best *gp.Individual)
    history         []*Stats
    plotters        []plotFunc
    plots           []Plot
    bestFit         float64
    done            bool
    step            chan stepMsg
    start           chan empty
}

// The PlotStats struct holds stats data which is served via HTTP in JSON format
type PlotStats struct {
    Done    bool
    Gen, MaxGen  int
    Headers []string
    Stats   [][]string
    Best    string
}

// Plot struct represents a flot plot which is served via HTTP in JSON format
type Plot struct {
    Label string        `json:"label"`
    Lines struct {
        Fill bool       `json:"fill"`
        LineWidth int   `json:"lineWidth"`
    } `json:"lines"`      
    Bubbles struct {
        Show  bool      `json:"show"`
        Fill  bool      `json:"fill"`
        Type  string    `json:"type"`
    } `json:"bubbles"`
    Data  [][3]float64  `json:"data"`
    Color string        `json:"color"`
}

// MainLoop function runs a model repeatedly with given model.
// Control of step and restart is controlled via web interface.
func MainLoop(problem *gp.Model, logger *Logger) {
     logger.InitChan()
     for {
        problem.Run(logger)
        logger.Reset()
    }
}

// InitChan initialises the channels used for ipc. 
// Send a message to the returned channel on start of next run.
func (l *Logger) InitChan() {
    l.start = make(chan empty)
    l.step = make(chan stepMsg)
}

// Reset reinitialisates the Logger struct. Call this before rerunning.
func (l *Logger) Reset() {
    l.Lock()
    defer l.Unlock()
    l.history = []*Stats{}
    l.bestFit = 0
    l.done = false
}

// update history and plots
func (l *Logger) update(s *Stats, pop gp.Population, gen int) bool {
    l.Lock()
    defer l.Unlock()
    done := gen >= l.MaxGen || s.Fit.Max >= l.TargetFitness
    if l.PrintStats {
        fmt.Println(s)
        if s.Fit.Max >= l.TargetFitness { fmt.Println("** SUCCESS **") }
    }
    if l.PrintBest && s.Fit.Max > l.bestFit {
        l.bestFit = s.Fit.Max
        fmt.Println(s.Best.Code.Format())
    }
    if l.history == nil {
        l.history = []*Stats{s}
    } else {
        l.history = append(l.history, s)
    }
    l.done  = done
    if l.plotters != nil {
        l.plots = make([]Plot, len(l.plotters))
        for i, plot := range l.plotters {
            l.plots[i] = plot(pop)
        }
    }
    return done
}

// Log logs a messages to stdout if PrintStats or PrintBest are set. 
// History stats are stored so they can be served via ServeHTTP.
func (l *Logger) Log(pop gp.Population, gen, evals int) bool {
    stats := Create(pop, gen, evals)
    done := l.update(stats, pop, gen)
    if l.OnStep != nil {
        l.OnStep(pop[stats.Fit.MaxIndex])
    }
    if done && l.OnDone != nil {
        l.OnDone(pop[stats.Fit.MaxIndex])
    }
    if l.step != nil {
        select {
        case <- l.start:
            if Debug { log.Println("got interrupt - quit run") }
            return true
        case l.step <- stepMsg{gen, done}:
            if Debug { log.Println("sent step msg", gen, done) }
        }
        if done {
            // wait for update before starting next run
            if Debug { log.Println("end of run - wait for restart")}
            <- l.start
        }
    }
    return done
}

// wrapper to log request urls
func logRequests(handler http.Handler) http.Handler {
    return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
        log.Println(r.URL)
        handler.ServeHTTP(w, r)
    })
}

// ListenAndServe method serve plots via http on port. HTML docs should be under the webRoot directory.
// This routine won't return so kick off any other processes as a goroutine.
func (l *Logger) ListenAndServe(port, webRoot string) {
    var err error
    if l.step != nil {
        http.HandleFunc("/step", 
            func (w http.ResponseWriter, r *http.Request) { sendJSON(w, <-l.step) })
        http.HandleFunc("/start", 
            func (w http.ResponseWriter, r *http.Request) { l.start <- empty{} })
    }
    http.HandleFunc("/stats/", l.statsHandler(len("/stats/")))
    http.HandleFunc("/plot/", l.plotHandler(len("/plot/")))
    http.HandleFunc("/graph", l.graphHandler())
    http.Handle("/", http.FileServer(http.Dir(webRoot)))
    log.Println("starting web server on", port)
    if Debug {
        err = http.ListenAndServe(port, logRequests(http.DefaultServeMux))
    } else {
        err = http.ListenAndServe(port, nil)
    }
    log.Fatal(err)
}

// convert to JSON and serve content
func sendJSON(w http.ResponseWriter, data interface{}) {
    jsonData, err := json.Marshal(data)
    if err != nil {
        http.Error(w, err.Error(), http.StatusInternalServerError)
        return
    }
    w.Header().Set("Content-Type", "application/json")
    w.Header().Set("Content-Length", strconv.Itoa(len(jsonData)))
    w.Write(jsonData)
}

// return handler to serve SVG graph of best individual via HTTP
func (l *Logger) graphHandler() func (http.ResponseWriter, *http.Request) { 
    return func (w http.ResponseWriter, r *http.Request) {
        if len(l.history) == 0 {
            http.NotFound(w, r)
            return
        }
        code := l.history[len(l.history)-1].Best.Code
        graph := code.Graph("best")
        data, err := gp.Layout(graph, "svg")
        if err != nil {
            http.Error(w, err.Error(), http.StatusInternalServerError)
            return
        }
        w.Header().Set("Content-Type", "image/svg+xml")
        w.Header().Set("Content-Length", strconv.Itoa(len(data)))
        w.Write(data)
    }
}

// get plot stats from firstGen onwards
func (l *Logger) getPlotStats(firstGen int) (data PlotStats) {
    data.Stats = [][]string{}
    data.Headers = LogHeaders()
    l.Lock()
    defer l.Unlock()
    last := len(l.history)-1
    data.Done = l.done
    data.Gen = last
    data.MaxGen = l.MaxGen
    if last >= 0 {
        if firstGen <= last {
            for _, s := range l.history[firstGen:] {
                data.Stats = append(data.Stats, s.LogValues())
            }
        }
        data.Best = l.history[last].Best.Code.Format()
    }
    return
}

// return handler to serve stats data via http
// URL is of form /stats/<from gen no.>
func (l *Logger) statsHandler(patternLen int) func (http.ResponseWriter, *http.Request) { 
    return func (w http.ResponseWriter, r *http.Request) {
        firstGen, err := strconv.Atoi(r.URL.Path[patternLen:])
        if err != nil || firstGen < 0 {
            http.NotFound(w, r)
            return
        }
        sendJSON(w, l.getPlotStats(firstGen))
    }
}

// return handler to serve plot data via http
// URL is of form /plot/<metric>
func (l *Logger) plotHandler(patternLen int) func (http.ResponseWriter, *http.Request) { 
    return func (w http.ResponseWriter, r *http.Request) {
        metric := r.URL.Path[patternLen:]
        l.Lock()
        defer l.Unlock()
        if metric == "Plot" {
            // custom plots
            if l.plots != nil { 
                sendJSON(w, l.plots) 
            } else {
                http.NotFound(w, r)
            }
            return
        }
        // stats metric plots (Fit, Size etc.)
        plots, err := getStatsPlots(l.history, metric)
        if err != nil {
            http.Error(w, err.Error(), http.StatusInternalServerError)
            return
        }
        sendJSON(w, plots)
    }
}

// RegisterPlot sets up a new callback to generate and send a plot back to the server.
func (l *Logger) RegisterPlot(plotter ...func(gp.Population)Plot) {
    if l.plotters == nil { l.plotters = []plotFunc{} }
    for _, p := range plotter {
        l.plotters = append(l.plotters, p)
    }
}

// Get the history data for the named field in a suitable format for plotting.
// Returns an error if name is not a valid field. Standard deviation is shown as a range.
func getStatsPlots(h []*Stats, name string) (lines []Plot, err error) {
    var val interface{}
    lines = make([]Plot, 3)
    colors := []string{"#ff0000", "#0000ff", "#b0b0ff"}
    for i, field := range []string{"Max", "Avg", "Std"} {
        lines[i].Data = make([][3]float64, len(h))
        lines[i].Color = colors[i]
        if field == "Std" {
            lines[i].Lines.Fill = true
            lines[i].Lines.LineWidth = 0
        } else {
            lines[i].Lines.LineWidth = 2
        }
        for j, stats := range h {
            if val, err = stats.Get(name + "." + field); err != nil {
                return
            }
            lines[i].Label = field + " " + name
            y, ok := val.(float64)
            if !ok {
                err = fmt.Errorf("Stats field %s could not be converted to float", name)
                return
            }
            if field == "Std" {
                avg := lines[i-1].Data[j][1]
                lines[i].Data[j] = [3]float64{ float64(j), avg-y, avg+y }
            } else {
                lines[i].Data[j] = [3]float64{ float64(j), y, 0 }
            }
        }
    }
    return
}

// NewPlot returns a new line Plot struct with given label and size
func NewPlot(label string, size int) Plot {
    p := Plot{}
    p.Label = label
    p.Lines.LineWidth = 2
    p.Bubbles.Fill = true
    p.Data = make([][3]float64, size)
    return p
}

// point a web browser to url - assumes Linux
func StartBrowser(url string) {
    for _, name := range WebBrowser {
        cmd := exec.Command(name, url)
        if err := cmd.Start(); err == nil { 
            log.Println("started browser", name, url)    
            return
        }
    }
    log.Println("no browser found - go to", url, "to view the data")
}


