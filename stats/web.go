package stats

import (
    "fmt"
    "log"
    "sync"
    "regexp"
    "strconv"
    "net"
    "net/http"
    "encoding/gob"
    "encoding/json"
    "github.com/jnb666/gogp/gp"
)

// History struct holds stats generated by model for each generation
// may be read and written by multiple threads so access is synced using a mutex
type History struct {
    sync.Mutex
    Stats []*Stats
}

// The PlotData struct holds the data structure which is served as JSON by ServeHTTP.
type PlotData struct {
    Done    bool
    MaxGen  int
    Headers []string
    Stats   [][]string
    Plots   []Plot
    Best    string
}

// Plot struct represents a flot plot which is served in JSON format
type Plot struct {
    Label string        `json:"label"`
    Lines struct {
        Fill bool       `json:"fill"`
        LineWidth int   `json:"lineWidth"`
    }                   `json:"lines"`
    Data  [][3]float64  `json:"data"`
}

// Logger implements the gp.Logger interface
type Logger struct {
    MaxGen int
    TargetFitness float64
    PrintStats bool
    PrintBest bool
    bestFit float64
    enc *gob.Encoder
}

// Dial connects the Logger to the TCP server for web based plotting.
func (l *Logger) Dial() error {
    port := "localhost" + TCPPort
    conn, err := net.Dial("tcp", port)
    if err != nil {
        return err
    }
    l.enc = gob.NewEncoder(conn)
    return nil
}

// Log logs a messages to stdout if PrintStats or PrintBest are set. 
// If Dial was called successfully then stats are sent via TCP to the server.
func (l *Logger) Log(pop gp.Population, gen, evals int) bool {
    s := Create(pop, gen, evals)
    s.MaxGen = l.MaxGen
    s.Done = gen >= l.MaxGen || s.Fit.Max >= l.TargetFitness
    if l.enc != nil {
        l.enc.Encode(s)
    }
    if l.PrintStats {
        fmt.Println(s)
        if s.Fit.Max >= l.TargetFitness {
            fmt.Println("** SUCCESS **") 
        }
    }
    if l.PrintBest {
        if s.Fit.Max > l.bestFit {
            l.bestFit = s.Fit.Max
            fmt.Println(s.Best)
        }
    }
    return s.Done
}

// NewHistory initialises a new History struct
func NewHistory() *History {
    return &History{ Stats: []*Stats{} }
}

// Reset method clears the history
func (h *History) Reset() {
    h.Lock()
    h.Stats = []*Stats{}
    h.Unlock()
}

// Append method adds a new stats record to the history
func (h *History) Append(s *Stats) {
    h.Lock()
    h.Stats = append(h.Stats, s)
    h.Unlock()
}

// GetPlots returns the history data for the named field in a suitable format for plotting.
// Returns an error if name is not a valid field. Standard deviation is shown as a range.
func GetPlots(h []*Stats, name string) (lines []Plot, err error) {
    var val interface{}
    lines = make([]Plot, 3)
    for i, field := range []string{"Max", "Avg", "Std"} {
        lines[i].Data = make([][3]float64, len(h))
        if field == "Std" {
            lines[i].Lines.Fill = true
            lines[i].Lines.LineWidth = 0
        } else {
            lines[i].Lines.LineWidth = 2
        }
        for j, stats := range h {
            if val, err = stats.Get(name + "." + field); err != nil {
                return
            }
            lines[i].Label = field + " " + name
            y, ok := val.(float64)
            if !ok {
                err = fmt.Errorf("Stats field %s could not be converted to float", name)
                return
            }
            if field == "Std" {
                avg := lines[i-1].Data[j][1]
                lines[i].Data[j] = [3]float64{ float64(j), avg-y, avg+y }
            } else {
                lines[i].Data[j] = [3]float64{ float64(j), y, 0 }
            }
        }
    }
    return
}

// GetPlotData creates a new PlotData struct from the history data.
// The plots are for the metric given in the field parameter.
// Stats are included from the generation given by the from parameter.
func GetPlotData(history *History, field string, from int) (data PlotData, err error) {
    data.Stats = [][]string{}
    data.Headers = LogHeaders()
    history.Lock()
    defer history.Unlock()
    last := len(history.Stats)-1
    if last < 0 {
        data.Plots = []Plot{}
        return
    }
    // get stats
    if from < len(history.Stats) {
        for _, s := range history.Stats[from:] {
            data.Stats = append(data.Stats, s.LogValues())
        }
    }
    // get per run values
    data.Done = history.Stats[last].Done
    data.MaxGen = history.Stats[last].MaxGen
    data.Best = history.Stats[last].Best
    // get plots
    data.Plots, err = GetPlots(history.Stats, field)
    return
}

// process incoming TCP connection
func (h *History) handleConn(conn net.Conn) {
    log.Println("accepted connection")
    dec := gob.NewDecoder(conn)
    h.Reset()
    for {
        s := &Stats{}
        if err := dec.Decode(s); err != nil {
            log.Println("error in gob Decode", err)
            break
        }
        h.Append(s)
        if s.Done { break }
    }
    log.Println("end of run")
}

// The Serve method starts a new TCP server listening on TCPport
// and will fork a goroutine to accept new Logger connections.
func (h *History) Serve() *History {
    ln, err := net.Listen("tcp", TCPPort)
    if err != nil {
        log.Fatal("error in Listen on", TCPPort, err)
    }
    go func() {
        for {
            conn, err := ln.Accept()
            if err != nil {
                log.Fatal("error in Accept on", TCPPort, err)
            }
            h.handleConn(conn)
        }
    } ()
    log.Println("stats Server listening on port", TCPPort)
    return h
}

var urlPath = regexp.MustCompile("/([a-zA-Z]+)+/([0-9]+)$")

// ServeHTTP implements the http.Handler interface to serve stats data encoded in JSON format
// URL is of the form .../<field>/<from gen>
func (h *History) ServeHTTP(w http.ResponseWriter, r *http.Request) {
    fields := urlPath.FindStringSubmatch(r.URL.Path)
    if fields == nil {
        http.NotFound(w, r)
        return
    }
    // extract the data
    from, _ := strconv.Atoi(fields[2])
    data, err := GetPlotData(h, fields[1], from)
    if err != nil {
        http.Error(w, err.Error(), http.StatusInternalServerError)
        return
    }
    // convert to JSON and serve content
    jsonData, err := json.Marshal(data)
    if err != nil {
        http.Error(w, err.Error(), http.StatusInternalServerError)
        return
    }
    w.Header().Set("Content-Type", "application/json")
    w.Header().Set("Content-Length", strconv.Itoa(len(jsonData)))
    w.Write(jsonData)
}

