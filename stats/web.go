package stats

import (
    "fmt"
    "log"
    "sync"
    "regexp"
    "strconv"
    "os/exec"
    "net/http"
    "encoding/json"
    "github.com/jnb666/gogp/gp"
)

// WebBrowser has paths to possible location of browser on this system
var WebBrowser = []string{
    "/etc/alternatives/gnome-www-browser",
    "/etc/alternatives/x-www-browser",
    "google-chrome",
    "firefox",
}

type plotFunc func(gp.Population) Plot

// Logger struct holds stats generated by model for each generation.
// It may be read and written by multiple threads so access is synced using a mutex.
// It implements the gp.Logger interface.
type Logger struct {
    sync.Mutex
    MaxGen          int
    TargetFitness   float64
    PrintStats      bool
    PrintBest       bool
    history         []*Stats
    plotters        []plotFunc
    plots           []Plot
    bestFit         float64
    done            bool
}

// The PlotData struct holds a set of plots which are served via http.
type PlotData struct {
    Done    bool
    Gen, MaxGen  int
    Headers []string
    Stats   [][]string
    Plots   []Plot
    Best    string
}

// Plot struct represents a flot plot which is served in JSON format
type Plot struct {
    Label string        `json:"label"`
    Lines struct {
        Fill bool       `json:"fill"`
        LineWidth int   `json:"lineWidth"`
    }                   `json:"lines"`
    Data  [][3]float64  `json:"data"`
}

// Log logs a messages to stdout if PrintStats or PrintBest are set. 
// History stats are stored so they can be served via ServeHTTP.
func (l *Logger) Log(pop gp.Population, gen, evals int) bool {
    s := Create(pop, gen, evals)
    done := gen >= l.MaxGen || s.Fit.Max >= l.TargetFitness
    // print stats
    if l.PrintStats {
        fmt.Println(s)
        if s.Fit.Max >= l.TargetFitness { fmt.Println("** SUCCESS **") }
    }
    if l.PrintBest && s.Fit.Max > l.bestFit {
        l.bestFit = s.Fit.Max
        fmt.Println(s.Best)
    }
    // update the history
    l.Lock()
    defer l.Unlock()
    if l.history == nil {
        l.history = []*Stats{s}
    } else {
        l.history = append(l.history, s)
    }
    l.done  = done
    // custom plots
    if l.plotters != nil {
        l.plots = make([]Plot, len(l.plotters))
        for i, plot := range l.plotters {
            l.plots[i] = plot(pop)
        }
    }
    return done
}

// wrapper to log request urls
func logRequests(handler http.Handler) http.Handler {
    return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
        log.Println(r.URL)
        handler.ServeHTTP(w, r)
    })
}

// ListenAndServe method serve plots via http on port. HTML docs should be under the webRoot directory.
// This routine won't return so kick off any other processes as a goroutine.
func (l *Logger) ListenAndServe(port, webRoot string) {
    var err error
    http.Handle("/data/", l)
    http.Handle("/", http.FileServer(http.Dir(webRoot)))
    log.Println("starting web server on", port)
    if Debug {
        err = http.ListenAndServe(port, logRequests(http.DefaultServeMux))
    } else {
        err = http.ListenAndServe(port, nil)
    }
    log.Fatal(err)
}

var urlPath = regexp.MustCompile("/([a-zA-Z]+)+/([0-9]+)$")

// ServeHTTP implements the http.Handler interface to serve stats data encoded in JSON format
// URL is of the form .../<field>/<from gen>
func (l *Logger) ServeHTTP(w http.ResponseWriter, r *http.Request) {
    fields := urlPath.FindStringSubmatch(r.URL.Path)
    if fields == nil {
        http.NotFound(w, r)
        return
    }
    // extract the data
    firstGen, _ := strconv.Atoi(fields[2])
    data, err := l.GetPlotData(fields[1], firstGen)
    if err != nil {
        http.Error(w, err.Error(), http.StatusInternalServerError)
        return
    }
    // convert to JSON and serve content
    jsonData, err := json.Marshal(data)
    if err != nil {
        http.Error(w, err.Error(), http.StatusInternalServerError)
        return
    }
    w.Header().Set("Content-Type", "application/json")
    w.Header().Set("Content-Length", strconv.Itoa(len(jsonData)))
    w.Write(jsonData)
}

// RegisterPlot sets up a new callback to generate and send a plot back to the server.
func (l *Logger) RegisterPlot(plotter func(gp.Population) Plot) {
    if l.plotters == nil {
        l.plotters = []plotFunc{plotter}
    } else {
        l.plotters = append(l.plotters, plotter)
    }
}

// Get the history data for the named field in a suitable format for plotting.
// Returns an error if name is not a valid field. Standard deviation is shown as a range.
func getStatsPlots(h []*Stats, name string) (lines []Plot, err error) {
    var val interface{}
    lines = make([]Plot, 3)
    for i, field := range []string{"Max", "Avg", "Std"} {
        lines[i].Data = make([][3]float64, len(h))
        if field == "Std" {
            lines[i].Lines.Fill = true
            lines[i].Lines.LineWidth = 0
        } else {
            lines[i].Lines.LineWidth = 2
        }
        for j, stats := range h {
            if val, err = stats.Get(name + "." + field); err != nil {
                return
            }
            lines[i].Label = field + " " + name
            y, ok := val.(float64)
            if !ok {
                err = fmt.Errorf("Stats field %s could not be converted to float", name)
                return
            }
            if field == "Std" {
                avg := lines[i-1].Data[j][1]
                lines[i].Data[j] = [3]float64{ float64(j), avg-y, avg+y }
            } else {
                lines[i].Data[j] = [3]float64{ float64(j), y, 0 }
            }
        }
    }
    return
}

// GetPlotData creates a new PlotData struct from the history data.
// The plots are for the metric given in the field parameter.
// Stats are included from the generation given by the firstGen parameter.
func (l *Logger) GetPlotData(field string, firstGen int) (data PlotData, err error) {
    data.Stats = [][]string{}
    data.Headers = LogHeaders()
    l.Lock()
    defer l.Unlock()
    last := len(l.history)-1
    data.Done = l.done
    data.Gen = last
    data.MaxGen = l.MaxGen
    data.Plots = []Plot{}
    if last < 0 { return }
    // get the stats
    if firstGen <= last {
        for _, s := range l.history[firstGen:] {
            data.Stats = append(data.Stats, s.LogValues())
        }
    }
    data.Best = l.history[last].Best
    if field == "Plot" && l.plots != nil {
        // custom plots
        data.Plots = l.plots
    } else {
        // stats metric plots (Fit, Size etc.)
        data.Plots, err = getStatsPlots(l.history, field)
    }
    return
}

// NewPlot returns a new line Plot struct with given label and size
func NewPlot(label string, size int) Plot {
    p := Plot{}
    p.Label = label
    p.Lines.LineWidth = 2
    p.Data = make([][3]float64, size)
    return p
}

// point a web browser to url - assumes Linux
func StartBrowser(url string) {
    for _, name := range WebBrowser {
        cmd := exec.Command(name, url)
        if err := cmd.Start(); err == nil { 
            log.Println("started browser", name, url)    
            return
        }
    }
    log.Println("no browser found - go to", url, "to view the data")
}


