package stats

import (
    "fmt"
    "log"
    "sync"
    "regexp"
    "strconv"
    "net"
    "net/http"
    "encoding/gob"
    "encoding/json"
    "github.com/jnb666/gogp/gp"
)

// History struct holds stats generated by model for each generation
// may be read and written by multiple threads so access is synced using a mutex
type History struct {
    sync.Mutex
    Stats  []*Stats
    Plots  []Plot
    MaxGen int
    Done   bool
}

// The PlotData struct holds the data structure which is served as JSON by ServeHTTP.
type PlotData struct {
    Done    bool
    Gen, MaxGen  int
    Headers []string
    Stats   [][]string
    Plots   []Plot
    Best    string
}

// Plot struct represents a flot plot which is served in JSON format
type Plot struct {
    Label string        `json:"label"`
    Lines struct {
        Fill bool       `json:"fill"`
        LineWidth int   `json:"lineWidth"`
    }                   `json:"lines"`
    Data  [][3]float64  `json:"data"`
}

// LogRecord struct is used by the Logger to pass info from the client
type LogRecord struct {
    *Stats
    Plots []Plot
    MaxGen int
    Done bool
}

type plotFunc func(gp.Population) Plot

// Logger implements the gp.Logger interface
type Logger struct {
    MaxGen int
    TargetFitness float64
    PrintStats bool
    PrintBest bool
    bestFit float64
    enc *gob.Encoder
    plotters []plotFunc
}

// Dial connects the Logger to the TCP server for web based plotting.
func (l *Logger) Dial() {
    port := "localhost" + TCPPort
    conn, err := net.Dial("tcp", port)
    if err != nil {
        log.Fatal("error connecting to plot server:", err)
    }
    l.enc = gob.NewEncoder(conn)
}

// RegisterPlot sets up a new callback to generate and send a plot back to the server.
func (l *Logger) RegisterPlot(plotter func(gp.Population) Plot) {
    if l.plotters == nil {
        l.plotters = []plotFunc{}
    }
    l.plotters = append(l.plotters, plotter)
}

// Log logs a messages to stdout if PrintStats or PrintBest are set. 
// If Dial was called successfully then stats are sent via TCP to the server.
func (l *Logger) Log(pop gp.Population, gen, evals int) bool {
    s := Create(pop, gen, evals)
    done := gen >= l.MaxGen || s.Fit.Max >= l.TargetFitness
    // gob encode and send data over TCP socket
    if l.enc != nil {
        rec := LogRecord{ Stats:s, MaxGen:l.MaxGen, Done:done, Plots: []Plot{}}
        if l.plotters != nil {
            for _, plot := range l.plotters {
                rec.Plots = append(rec.Plots, plot(pop))
            }
        }
        l.enc.Encode(rec)
    }
    // print stats
    if l.PrintStats {
        fmt.Println(s)
        if s.Fit.Max >= l.TargetFitness {
            fmt.Println("** SUCCESS **") 
        }
    }
    if l.PrintBest {
        if s.Fit.Max > l.bestFit {
            l.bestFit = s.Fit.Max
            fmt.Println(s.Best)
        }
    }
    return done
}

// NewHistory initialises a new History struct
func NewHistory() *History {
    return &History{ Stats: []*Stats{}, Plots: []Plot{} }
}

// Reset method clears the history
func (h *History) Reset() {
    h.Lock()
    defer h.Unlock()
    h.Stats = []*Stats{}
    h.Done = false
    h.MaxGen = 0
    h.Plots = []Plot{}
}

// Append method adds a new log record to the history
func (h *History) Append(rec *LogRecord) {
    h.Lock()
    defer h.Unlock()
    h.Stats = append(h.Stats, rec.Stats)
    h.MaxGen = rec.MaxGen
    h.Done = rec.Done
    h.Plots = rec.Plots
}

// Get the history data for the named field in a suitable format for plotting.
// Returns an error if name is not a valid field. Standard deviation is shown as a range.
func getStatsPlots(h []*Stats, name string) (lines []Plot, err error) {
    var val interface{}
    lines = make([]Plot, 3)
    for i, field := range []string{"Max", "Avg", "Std"} {
        lines[i].Data = make([][3]float64, len(h))
        if field == "Std" {
            lines[i].Lines.Fill = true
            lines[i].Lines.LineWidth = 0
        } else {
            lines[i].Lines.LineWidth = 2
        }
        for j, stats := range h {
            if val, err = stats.Get(name + "." + field); err != nil {
                return
            }
            lines[i].Label = field + " " + name
            y, ok := val.(float64)
            if !ok {
                err = fmt.Errorf("Stats field %s could not be converted to float", name)
                return
            }
            if field == "Std" {
                avg := lines[i-1].Data[j][1]
                lines[i].Data[j] = [3]float64{ float64(j), avg-y, avg+y }
            } else {
                lines[i].Data[j] = [3]float64{ float64(j), y, 0 }
            }
        }
    }
    return
}

// GetPlotData creates a new PlotData struct from the history data.
// The plots are for the metric given in the field parameter.
// Stats are included from the generation given by the firstGen parameter.
func (h *History) GetPlotData(field string, firstGen int) (data PlotData, err error) {
    data.Stats = [][]string{}
    data.Headers = LogHeaders()
    h.Lock()
    defer h.Unlock()
    last := len(h.Stats)-1
    data.Done = h.Done
    data.Gen = last
    data.MaxGen = h.MaxGen
    if last < 0 {
        data.Plots = []Plot{}
        return
    }
    // get the stats
    if firstGen <= last {
        for _, s := range h.Stats[firstGen:] {
            data.Stats = append(data.Stats, s.LogValues())
        }
    }
    data.Best = h.Stats[last].Best
    if field == "Plot" {
        // custom plots
        data.Plots = h.Plots
    } else {
        // stats metric plots (Fit, Size etc.)
        data.Plots, err = getStatsPlots(h.Stats, field)
    }
    return
}

// process incoming TCP connection
func (h *History) handleConn(conn net.Conn) {
    log.Println("accepted connection")
    dec := gob.NewDecoder(conn)
    h.Reset()
    for {
        rec := &LogRecord{}
        if err := dec.Decode(rec); err != nil {
            log.Println("error in gob Decode", err)
            break
        }
        h.Append(rec)
        if rec.Done { break }
    }
    log.Println("end of run")
}

// The Serve method starts a new TCP server listening on TCPport
// and will fork a goroutine to accept new Logger connections.
func (h *History) Serve() *History {
    ln, err := net.Listen("tcp", TCPPort)
    if err != nil {
        log.Fatal("error in Listen on", TCPPort, err)
    }
    go func() {
        for {
            conn, err := ln.Accept()
            if err != nil {
                log.Fatal("error in Accept on", TCPPort, err)
            }
            h.handleConn(conn)
        }
    } ()
    log.Println("stats Server listening on port", TCPPort)
    return h
}

var urlPath = regexp.MustCompile("/([a-zA-Z]+)+/([0-9]+)$")

// ServeHTTP implements the http.Handler interface to serve stats data encoded in JSON format
// URL is of the form .../<field>/<from gen>
func (h *History) ServeHTTP(w http.ResponseWriter, r *http.Request) {
    fields := urlPath.FindStringSubmatch(r.URL.Path)
    if fields == nil {
        http.NotFound(w, r)
        return
    }
    // extract the data
    firstGen, _ := strconv.Atoi(fields[2])
    data, err := h.GetPlotData(fields[1], firstGen)
    if err != nil {
        http.Error(w, err.Error(), http.StatusInternalServerError)
        return
    }
    // convert to JSON and serve content
    jsonData, err := json.Marshal(data)
    if err != nil {
        http.Error(w, err.Error(), http.StatusInternalServerError)
        return
    }
    w.Header().Set("Content-Type", "application/json")
    w.Header().Set("Content-Length", strconv.Itoa(len(jsonData)))
    w.Write(jsonData)
}

// NewPlot returns a new line Plot struct with given label and size
func NewPlot(label string, size int) Plot {
    p := Plot{}
    p.Label = label
    p.Lines.LineWidth = 2
    p.Data = make([][3]float64, size)
    return p
}

