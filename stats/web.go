package stats

import (
	"encoding/json"
	"fmt"
	"github.com/jnb666/gogp/gp"
	"github.com/mattn/go-gtk/gtk"
	"github.com/mattn/go-webkit/webkit"
	"log"
	"net/http"
	"strconv"
	"sync"
)

type stepMsg struct {
	Gen  int
	Done bool
}

type empty struct{}

type opt [2]string

var options = []opt{
	{"Hist", "fit hist"},
	{"Fit", "fitness"},
	{"Size", "size"},
	{"Depth", "depth"},
}

// Logger struct holds stats generated by model for each generation.
// It may be read and written by multiple threads so access is synced using a mutex.
// It implements the gp.Logger interface.
// If OnStep is non nil then it is called with best individual at each generation.
// If OnDone is non nil then it is called with best individual at end of run.
type Logger struct {
	sync.Mutex
	MaxGen        int
	TargetFitness float64
	PrintStats    bool
	PrintBest     bool
	OnStep        func(best *gp.Individual)
	OnDone        func(best *gp.Individual)
	history       []*Stats
	options       []opt
	plotters      []func(gp.Population) Plot
	plots         []Plot
	svgplotter    func(gp.Population) []byte
	svgplot       []byte
	bestFit       float64
	done          bool
	step          chan stepMsg
	start         chan empty
}

// The PlotStats struct holds stats data which is served via HTTP in JSON format
type PlotStats struct {
	Done        bool
	Gen, MaxGen int
	Headers     []string
	Stats       [][]string
	Best        string
}

// Plot struct represents a flot plot which is served via HTTP in JSON format
type Plot struct {
	Label string `json:"label"`
	Lines struct {
		Show      bool `json:"show"`
		Fill      bool `json:"fill"`
		LineWidth int  `json:"lineWidth"`
	} `json:"lines"`
	Bars struct {
		Show     bool    `json:"show"`
		Fill     bool    `json:"fill"`
		BarWidth float64 `json:"barWidth"`
	} `json:"bars"`
	Bubbles struct {
		Show bool `json:"show"`
		Fill bool `json:"fill"`
	} `json:"bubbles"`
	Data  [][3]float64 `json:"data"`
	Color string       `json:"color"`
}

// NewLogger creates and retuns a new logger struct
func NewLogger(maxGen int, targetFitness float64) *Logger {
	l := Logger{MaxGen: maxGen, TargetFitness: targetFitness}
	l.options = append([]opt{}, options...)
	return &l
}

// InitChan initialises the channels used for ipc for the web interface
func (l *Logger) InitChan() {
	l.start = make(chan empty)
	l.step = make(chan stepMsg)
}

// Reset reinitialisates the Logger struct. Call this before rerunning.
func (l *Logger) Reset() {
	l.Lock()
	defer l.Unlock()
	l.history = []*Stats{}
	l.bestFit = 0
	l.done = false
}

// update history and plots
func (l *Logger) update(s *Stats, pop gp.Population, gen int) bool {
	l.Lock()
	defer l.Unlock()
	done := gen >= l.MaxGen || s.Fit.Max >= l.TargetFitness
	if l.PrintStats {
		fmt.Println(s)
		if s.Fit.Max >= l.TargetFitness {
			fmt.Println("** SUCCESS **")
		}
	}
	if l.PrintBest && s.Fit.Max > l.bestFit {
		l.bestFit = s.Fit.Max
		fmt.Println(s.Best.Code.Format())
	}
	if l.history == nil {
		l.history = []*Stats{s}
	} else {
		l.history = append(l.history, s)
	}
	l.done = done
	if l.plotters != nil {
		l.plots = make([]Plot, len(l.plotters))
		for i, plotter := range l.plotters {
			l.plots[i] = plotter(pop)
		}
	}
	if l.svgplotter != nil {
		l.svgplot = l.svgplotter(pop)
	}
	return done
}

// Log logs a messages to stdout if PrintStats or PrintBest are set.
// History stats are stored so they can be served via ServeHTTP.
func (l *Logger) Log(pop gp.Population, gen, evals int) bool {
	stats := Create(pop, gen, evals)
	done := l.update(stats, pop, gen)
	if l.OnStep != nil {
		l.OnStep(pop[stats.Fit.MaxIndex])
	}
	if done && l.OnDone != nil {
		l.OnDone(pop[stats.Fit.MaxIndex])
	}
	if l.step != nil {
		select {
		case <-l.start:
			if Debug {
				log.Println("got interrupt - quit run")
			}
			return true
		case l.step <- stepMsg{gen, done}:
			if Debug {
				log.Println("sent step msg", gen, done)
			}
		}
		if done {
			// wait for update before starting next run
			if Debug {
				log.Println("end of run - wait for restart")
			}
			<-l.start
		}
	}
	return done
}

// wrapper to log request urls
func logRequests(handler http.Handler) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		log.Println(r.URL)
		handler.ServeHTTP(w, r)
	})
}

// ListenAndServe method serve plots via http on port. HTML docs should be under the webRoot directory.
// This routine won't return so kick off any other processes as a goroutine.
func (l *Logger) ListenAndServe(port, webRoot string) {
	var err error
	if l.step != nil {
		http.HandleFunc("/step", func(w http.ResponseWriter, r *http.Request) {
			sendJSON(w, r, <-l.step)
		})
		http.HandleFunc("/start", func(w http.ResponseWriter, r *http.Request) {
			l.start <- empty{}
		})
	}
	http.HandleFunc("/stats/", l.statsHandler(len("/stats/")))
	http.HandleFunc("/plot/List", func(w http.ResponseWriter, r *http.Request) {
		sendJSON(w, r, l.options)
	})
	http.HandleFunc("/plot/Plot", func(w http.ResponseWriter, r *http.Request) {
		sendJSON(w, r, l.plots)
	})
	http.HandleFunc("/plot/SVGPlot", func(w http.ResponseWriter, r *http.Request) {
		send(w, r, l.svgplot, "image/svg+xml")
	})
	http.HandleFunc("/plot/Hist", l.histogramPlotHandler())
	http.HandleFunc("/plot/", l.statsPlotHandler(len("/plot/")))
	http.HandleFunc("/graph", l.graphHandler())
	http.Handle("/", http.FileServer(http.Dir(webRoot)))
	log.Println("starting web server on", port)
	if Debug {
		err = http.ListenAndServe(port, logRequests(http.DefaultServeMux))
	} else {
		err = http.ListenAndServe(port, nil)
	}
	log.Fatal(err)
}

// convert to JSON and serve content
func sendJSON(w http.ResponseWriter, r *http.Request, data interface{}) {
	if data == nil {
		http.NotFound(w, r)
		return
	}
	jsonData, err := json.Marshal(data)
	if err != nil {
		http.Error(w, err.Error(), http.StatusInternalServerError)
		return
	}
	send(w, r, jsonData, "application/json")
}

// serve data as given content type
func send(w http.ResponseWriter, r *http.Request, data []byte, contentType string) {
	if data == nil {
		http.NotFound(w, r)
		return
	}
	w.Header().Set("Content-Type", contentType)
	w.Header().Set("Content-Length", strconv.Itoa(len(data)))
	w.Write(data)
}

// return handler to serve SVG graph of best individual via HTTP
func (l *Logger) graphHandler() func(http.ResponseWriter, *http.Request) {
	return func(w http.ResponseWriter, r *http.Request) {
		if len(l.history) == 0 {
			http.NotFound(w, r)
			return
		}
		code := l.history[len(l.history)-1].Best.Code
		graph := code.Graph("best")
		data, err := gp.Layout(graph, "svg")
		if err != nil {
			http.Error(w, err.Error(), http.StatusInternalServerError)
			return
		}
		send(w, r, data, "image/svg+xml")
	}
}

// get plot stats from firstGen onwards
func (l *Logger) getPlotStats(firstGen int) (data PlotStats) {
	data.Stats = [][]string{}
	data.Headers = LogHeaders()
	l.Lock()
	defer l.Unlock()
	last := len(l.history) - 1
	data.Done = l.done
	data.Gen = last
	data.MaxGen = l.MaxGen
	if last >= 0 {
		if firstGen <= last {
			for _, s := range l.history[firstGen:] {
				data.Stats = append(data.Stats, s.LogValues())
			}
		}
		data.Best = l.history[last].Best.Code.Format()
	}
	return
}

// return handler to serve stats data via http
// URL is of form /stats/<from gen no.>
func (l *Logger) statsHandler(patternLen int) func(http.ResponseWriter, *http.Request) {
	return func(w http.ResponseWriter, r *http.Request) {
		firstGen, err := strconv.Atoi(r.URL.Path[patternLen:])
		if err != nil || firstGen < 0 {
			http.NotFound(w, r)
			return
		}
		sendJSON(w, r, l.getPlotStats(firstGen))
	}
}

// return handler to serve histogram of fitness via http. URL is of form /plot/Hist
func (l *Logger) histogramPlotHandler() func(http.ResponseWriter, *http.Request) {
	return func(w http.ResponseWriter, r *http.Request) {
		plot := NewBarPlot("fitness", HistBars)
		plot.Color = "#0000ff"
		l.Lock()
		defer l.Unlock()
		hist := l.history[len(l.history)-1].FitHist
		for i, num := range hist {
			plot.Data[i] = [3]float64{float64(i) / float64(HistBars), float64(num), 0}
		}
		sendJSON(w, r, []Plot{plot})
	}
}

// return handler to serve plot data via http. URL is of form /plot/<metric>
func (l *Logger) statsPlotHandler(patternLen int) func(http.ResponseWriter, *http.Request) {
	return func(w http.ResponseWriter, r *http.Request) {
		l.Lock()
		defer l.Unlock()
		plots, err := getStatsPlots(l.history, r.URL.Path[patternLen:])
		if err != nil {
			http.Error(w, err.Error(), http.StatusInternalServerError)
			return
		}
		sendJSON(w, r, plots)
	}
}

// RegisterPlot sets up a new callback to generate and send a plot back to the server.
func (l *Logger) RegisterPlot(name string, plotter ...func(gp.Population) Plot) {
	if l.plotters == nil {
		l.plotters = []func(gp.Population) Plot{}
	}
	for _, p := range plotter {
		l.plotters = append(l.plotters, p)
	}
	l.options = append([]opt{{"Plot", name}}, l.options...)
}

// RegisterSVGPlot sets up a new callback to generate and send a raw SVG plot back to the server.
func (l *Logger) RegisterSVGPlot(name string, plotter func(gp.Population) []byte) {
	l.svgplotter = plotter
	l.options = append([]opt{{"SVGPlot", name}}, l.options...)
}

// Get the history data for the named field in a suitable format for plotting.
// Returns an error if name is not a valid field. Standard deviation is shown as a range.
func getStatsPlots(h []*Stats, name string) (lines []Plot, err error) {
	var val interface{}
	lines = make([]Plot, 3)
	colors := []string{"#ff0000", "#0000ff", "#b0b0ff"}
	for i, field := range []string{"Max", "Avg", "Std"} {
		lines[i].Lines.Show = true
		lines[i].Data = make([][3]float64, len(h))
		lines[i].Color = colors[i]
		if field == "Std" {
			lines[i].Lines.Fill = true
			lines[i].Lines.LineWidth = 0
		} else {
			lines[i].Lines.LineWidth = 2
		}
		for j, stats := range h {
			if val, err = stats.Get(name + "." + field); err != nil {
				return
			}
			lines[i].Label = field + " " + name
			y, ok := val.(float64)
			if !ok {
				err = fmt.Errorf("Stats field %s could not be converted to float", name)
				return
			}
			if field == "Std" {
				avg := lines[i-1].Data[j][1]
				lines[i].Data[j] = [3]float64{float64(j), avg - y, avg + y}
			} else {
				lines[i].Data[j] = [3]float64{float64(j), y, 0}
			}
		}
	}
	return
}

// NewPlot returns a new line Plot struct with given label and size
func NewPlot(label string, size int) Plot {
	p := Plot{}
	p.Label = label
	p.Lines.Show = true
	p.Lines.LineWidth = 2
	p.Bubbles.Fill = true
	p.Data = make([][3]float64, size)
	return p
}

// NewBarPlot returns a new bar Plot struct with given label and size
func NewBarPlot(label string, size int) Plot {
	p := Plot{}
	p.Label = label
	p.Bars.Show = true
	p.Bars.Fill = true
	p.Bars.BarWidth = 1 / float64(HistBars)
	p.Data = make([][3]float64, size)
	return p
}

// StartBrowser launches a web browser with given url and size
func StartBrowser(url string, width, height int) {
	gtk.Init(nil)
	window := gtk.NewWindow(gtk.WINDOW_TOPLEVEL)
	window.SetTitle("gogp")
	window.Connect("destroy", gtk.MainQuit)
	swin := gtk.NewScrolledWindow(nil, nil)
	swin.SetPolicy(gtk.POLICY_AUTOMATIC, gtk.POLICY_AUTOMATIC)
	swin.SetShadowType(gtk.SHADOW_IN)
	webview := webkit.NewWebView()
	swin.Add(webview)
	window.Add(swin)
	window.SetSizeRequest(width, height)
	webview.LoadUri(url)
	window.ShowAll()
	gtk.Main()
}

// MainLoop function runs a model repeatedly with given logger.
// Control of step and restart is controlled via web interface.
func MainLoop(problem *gp.Model, logger *Logger, port, webRoot string) {
	logger.InitChan()
	go logger.ListenAndServe(port, webRoot)
	go func() {
		for {
			problem.Run(logger)
			logger.Reset()
		}
	}()
	StartBrowser("http://localhost"+port, BrowserWidth, BrowserHeight)
}
